// ----------------------------------------------------------------------------
// mobot.haiq - Mobile Robotics Simple Scenario HaiQ model 
// (c) 2017 Javier Camara 
// Institute for Software Research, School of Computer Science
// Carnegie Mellon University
// Email: jcmoreno@cs.cmu.edu
// Web: http://www.scs.cmu.edu/~jcmoreno
// 5/11/2017
// ----------------------------------------------------------------------------

ModelType: mdp


// ----------------------------------------------------------------------------
// Software architecture
// ----------------------------------------------------------------------------

const DISABLED=0;
const ENABLED=1;

// Components
abstract sig component {}
</
  formula INIT=0;
  var status:[DISABLED..ENABLED] init INIT;
  var done : bool init false;
  [this:enable] (done=false) & (status=DISABLED) -> (status'=ENABLED) & (done'=true);
  [this:disable] (done=false) & (status=ENABLED) -> (status'=DISABLED) & (done'=true);
/>

abstract sig sensing extends component {}
</
/>

abstract sig localization extends component {}
</
/>


lone sig kinect extends sensing {}
</
/>

lone sig lidar extends sensing {}
</
/>

lone sig camera extends sensing {} // Simplified front-and back to just one type (always go together)
</
/>

lone sig amcl extends localization {}
</
/>

lone sig mrpt extends localization {}
</
/>

lone sig markerLocalization extends localization{}
</
/>

lone sig laserscanNodelet extends component {}
</
/>

lone sig markerRecognizer extends component {} // Simplified to just one type (like cameras)
</
/>

lone sig headlamp extends component {}
</
/>

abstract sig mapServer extends component{}
</
/>

lone sig mapServerObs extends mapServer{}
</
/>

lone sig mapServerStd extends mapServer{}
</
/>

// Options
abstract sig option {}
</
/>

abstract sig speedSetting extends option {}
</
/>

lone sig halfSpeedSetting extends speedSetting {}
</
/>

lone sig fullSpeedSetting extends speedSetting {}
</
/>

lone sig safeSpeedSetting extends speedSetting {}
</
/>

// Constraints
pred config{
  some kinect <=> some laserscanNodelet
  some camera <=> some markerLocalization
  some camera <=> some markerRecognizer
  some camera <=> some mapServerObs
  some headlamp => some camera
  one sensing
  one localization
  one speedSetting
  one mapServer
}

// ----------------------------------------------------------------------------
// Mission
// ----------------------------------------------------------------------------

abstract sig loc { conn : set loc }
</ 
  var robotIn: bool init false;
  formula pbump=0;
  formula econf1 = 1;
  formula econf2 = 2;
  
  [conn:moveTo] (robotIn) -> (robotIn'=false);
  [conn:moveTo] (!robotIn) & (conn.robotIn) -> 1-pbump : (robotIn'=true) + pbump : (robotIn'=false);

  reward energy [conn:moveTo] (!robotIn): true? econf1 : econf2 ;
/>

abstract sig startloc extends loc {}
</
  var robotIn: bool init true;
/>
abstract sig targetloc extends loc {}
</
  var robotIn: bool init false;
/>
fact { disj[targetloc, startloc] }

fact { all l:loc | not l in l.conn }
fact { all l,l':loc | l in l'.conn implies l' in l.conn }
fact { all l:loc-(startloc+targetloc) | #l.conn < 3}
fact { all l:startloc+targetloc | #l.conn = 1}
fact { one s:startloc | one t:targetloc | t in s.^conn}


one sig l1 extends startloc {} 
</
	formula pbump=0;
/>
one sig l2 extends loc {}
</
	formula pbump=0;
/>
one sig l3 extends loc {}
</
	formula pbump=0;
/>
one sig l4 extends loc {}
</
	formula pbump=0.5;
/>
one sig l5 extends loc {}
</
	formula pbump=0;
/>

one sig l6 extends targetloc {}
</
  formula pbump=0;
/>


fact {disj[l1.conn, loc-(l2+l4)] and disj[l2.conn, loc-(l1+l3)] and disj[l3.conn, loc-(l5+l4+l2)] and disj[l4.conn, loc-(l1+l3)] and disj[l5.conn, loc-(l3+l6)] and disj[l6.conn, loc-(l5)]}
// fact {l1.conn = l2 + l4 and l2.conn = l1 + l3 and l3.conn = l5 + l4 + l2 and l4.conn = l1 + l3 and l5.conn = l3 + l6 and l6.conn = l5}

label robotInStart [some startloc:robotIn=true]      
label robotInTarget [some targetloc:robotIn=true]
label reconfDone [all component:done=true] 
property rangeP [F robotInStart] 
property rangeP [F robotInTarget] 
property maxPmax [F (robotInTarget & reconfDone)]

pred mobot{#loc>4}

pred scenario{mobot and config}

run scenario for 7 loc
